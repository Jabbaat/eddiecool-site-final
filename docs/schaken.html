<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schaak Training App</title>
    <style>
        /* --- Algemene Stijlen --- */
        :root {
            --primary-start: #667eea;
            --primary-end: #764ba2;
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --border-color: #8B4513;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --error-color: #dc3545;
            --highlight-color: #4caf50;
            --hint-color: #ff9800;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        /* --- Layout --- */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            align-items: start;
        }

        .game-area, .sidebar {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .sidebar {
            height: fit-content;
        }

        /* --- Header & ELO --- */
        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .elo-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .elo-item {
            background: linear-gradient(135deg, var(--primary-start), var(--primary-end));
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            text-align: center;
            font-weight: bold;
            flex: 1;
            max-width: 200px;
        }

        .elo-item span {
            display: block;
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        
        /* --- Schaakbord --- */
        .chessboard {
            width: 100%;
            max-width: 480px;
            margin: 0 auto 20px;
            border: 4px solid var(--border-color);
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            aspect-ratio: 1 / 1; /* Zorgt ervoor dat het bord altijd vierkant blijft */
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1rem, 8vw, 2.5rem); /* Dynamische lettergrootte voor schaakstukken */
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
        }

        .square.light { background-color: var(--light-square); }
        .square.dark { background-color: var(--dark-square); }
        .square:hover { box-shadow: inset 0 0 0 3px var(--warning-color); }
        .square.selected { box-shadow: inset 0 0 0 4px var(--highlight-color) !important; }
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.2);
        }
        .square.last-move { background-color: rgba(255, 235, 59, 0.4) !important; }
        .square.hint {
            box-shadow: inset 0 0 0 4px var(--hint-color) !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* --- Knoppen en Controls --- */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, var(--primary-start), var(--primary-end));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            flex-grow: 1; /* Knoppen groeien mee */
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .level-selector select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            width: 100%;
            max-width: 300px;
        }

        /* --- Sidebar --- */
        .sidebar h3 {
            margin-bottom: 15px;
            font-size: 1.3rem;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }

        .feedback {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid var(--success-color);
        }

        .feedback.warning { border-left-color: var(--warning-color); background: #fff8e1; }
        .feedback.error { border-left-color: var(--error-color); background: #ffebee; }

        .moves-list {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .move-pair { margin-bottom: 8px; }

        .game-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .game-status.playing { background: #e3f2fd; color: #1976d2; }
        .game-status.checkmate { background: #ffebee; color: #c62828; }
        .game-status.stalemate { background: #fff3e0; color: #ef6c00; }

        /* --- Media Queries (Responsive Design) --- */
        /* Voor tablets en kleinere laptops */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .sidebar {
                order: 3; /* Plaatst de sidebar onderaan op mobiel */
            }
        }
        
        /* Voor tablets */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .game-area, .sidebar { padding: 20px 15px; }
            .header h1 { font-size: 2rem; }
            .elo-display { flex-direction: column; gap: 10px; align-items: center; }
            .elo-item { max-width: 280px; width: 100%;}
            .chessboard {
                width: 100%; /* Neemt de volledige breedte van de container */
            }
        }

        /* Voor mobiele telefoons */
        @media (max-width: 480px) {
            .game-area, .sidebar { padding: 15px; }
            .header h1 { font-size: 1.8rem; }
            .game-controls {
                flex-direction: column; /* Zet knoppen onder elkaar */
            }
            .btn {
                padding: 14px 20px;
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <!-- Spelgedeelte -->
        <section class="game-area">
            <header class="header">
                <h1>‚ôî Schaak Training ‚ôõ</h1>
                <div class="elo-display">
                    <div class="elo-item">
                        <span id="current-elo">1000</span>
                        <div>Jouw ELO</div>
                    </div>
                    <div class="elo-item">
                        <span id="target-elo">1200</span>
                        <div>Tegenstander</div>
                    </div>
                </div>
                <div class="level-selector">
                    <select id="difficulty">
                        <option value="1000">Beginner (1000-1100)</option>
                        <option value="1200" selected>Gevorderd beginner (1200-1300)</option>
                        <option value="1400">Intermediate (1400-1500)</option>
                        <option value="1600">Gevorderd (1600-1700)</option>
                        <option value="1800">Expert (1800+)</option>
                    </select>
                </div>
            </header>

            <div class="game-status playing" id="game-status">
                Jouw beurt - Speel met wit
            </div>

            <div class="chessboard" id="chessboard"></div>

            <div class="game-controls">
                <button class="btn" id="hint-btn">üí° Hint</button>
                <button class="btn" id="undo-btn">‚Ü∂ Zet terug</button>
                <button class="btn" id="new-game-btn">üéÆ Nieuw spel</button>
            </div>
        </section>

        <!-- Zijbalk met informatie -->
        <aside class="sidebar">
            <div class="game-info">
                <h3>üéØ Feedback</h3>
                <div class="feedback" id="feedback">
                    Welkom! Klik op een wit stuk om te beginnen.
                </div>

                <h3>üìù Zetten</h3>
                <div class="moves-list" id="moves-list">
                    <div style="text-align: center; color: #666; font-style: italic;">
                        Nog geen zetten gespeeld
                    </div>
                </div>

                <h3>üìä Voortgang</h3>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                    <div style="margin-bottom: 10px;">
                        <strong>Gespeelde partijen:</strong> <span id="games-played">0</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>Gewonnen:</strong> <span id="games-won">0</span>
                    </div>
                    <div>
                        <strong>Win percentage:</strong> <span id="win-rate">0%</span>
                    </div>
                </div>
            </div>
        </aside>
    </main>

    <script>
        class ChessGame {
            constructor() {
                // Initi√´le staat van het spel
                this.board = [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
                
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.gameOver = false;
                this.moves = [];
                this.moveHistory = [];
                this.lastMove = null;
                this.difficulty = 1200;
                this.playerElo = 1000;
                this.gamesPlayed = 0;
                this.gamesWon = 0;
                
                this.castlingRights = {
                    whiteKingSide: true, whiteQueenSide: true,
                    blackKingSide: true, blackQueenSide: true
                };
                
                this.enPassantTarget = null;
                
                // VERBETERING: Cache DOM-elementen voor betere prestaties
                this.cacheDOMElements();
                
                this.renderBoard();
                this.updateGameStatus();
                this.setupEventListeners();
            }

            cacheDOMElements() {
                this.chessboardEl = document.getElementById('chessboard');
                this.feedbackEl = document.getElementById('feedback');
                this.movesListEl = document.getElementById('moves-list');
                this.gameStatusEl = document.getElementById('game-status');
                this.targetEloEl = document.getElementById('target-elo');
                this.currentEloEl = document.getElementById('current-elo');
                this.gamesPlayedEl = document.getElementById('games-played');
                this.gamesWonEl = document.getElementById('games-won');
                this.winRateEl = document.getElementById('win-rate');
                this.hintBtn = document.getElementById('hint-btn');
                this.undoBtn = document.getElementById('undo-btn');
                this.newGameBtn = document.getElementById('new-game-btn');
                this.difficultySelector = document.getElementById('difficulty');
            }

            // VERBETERING: Event listeners worden in JS gekoppeld i.p.v. met onclick in HTML
            setupEventListeners() {
                this.difficultySelector.addEventListener('change', (e) => {
                    this.difficulty = parseInt(e.target.value);
                    this.targetEloEl.textContent = this.difficulty;
                    this.newGame();
                });
                
                this.hintBtn.addEventListener('click', () => this.showHint());
                this.undoBtn.addEventListener('click', () => this.undoMove());
                this.newGameBtn.addEventListener('click', () => this.newGame());
            }

            renderBoard() {
                this.chessboardEl.innerHTML = '';

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        
                        // FIX: De class-toewijzing had een syntaxisfout. Dit is de correcte manier.
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        
                        const piece = this.board[row][col];
                        if (piece) {
                            square.textContent = this.getPieceSymbol(piece);
                        }

                        if (this.lastMove && 
                            ((row === this.lastMove.fromRow && col === this.lastMove.fromCol) ||
                             (row === this.lastMove.toRow && col === this.lastMove.toCol))) {
                            square.classList.add('last-move');
                        }
                        
                        // Voeg een data-attribuut toe om rij/kolom makkelijk terug te vinden
                        square.dataset.row = row;
                        square.dataset.col = col;

                        this.chessboardEl.appendChild(square);
                    }
                }
                
                // Koppel de click handler aan het hele bord voor effici√´ntie
                this.chessboardEl.onclick = (e) => {
                    const squareEl = e.target.closest('.square');
                    if (squareEl) {
                        const row = parseInt(squareEl.dataset.row);
                        const col = parseInt(squareEl.dataset.col);
                        this.handleSquareClick(row, col);
                    }
                };
            }

            getPieceSymbol(piece) {
                const symbols = {
                    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
                    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
                };
                return symbols[piece] || '';
            }

            handleSquareClick(row, col) {
                if (this.gameOver || this.currentPlayer !== 'white') {
                    return;
                }

                const piece = this.board[row][col];
                
                if (this.selectedSquare) {
                    // Zet uitvoeren of selectie wijzigen
                    if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                        this.selectedSquare = null;
                        this.clearHighlights();
                        
                        if (!this.gameOver) {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    } else if (piece && this.isWhitePiece(piece)) {
                        this.selectedSquare = { row, col };
                        this.highlightPossibleMoves(row, col);
                    } else {
                        this.selectedSquare = null;
                        this.clearHighlights();
                    }
                } else if (piece && this.isWhitePiece(piece)) {
                    // Een stuk selecteren
                    this.selectedSquare = { row, col };
                    this.highlightPossibleMoves(row, col);
                }
            }

            isWhitePiece(piece) { return piece && piece === piece.toUpperCase(); }
            isBlackPiece(piece) { return piece && piece === piece.toLowerCase(); }

            clearHighlights() {
                this.chessboardEl.querySelectorAll('.square').forEach(s => {
                    s.classList.remove('selected', 'possible-move', 'hint');
                });
            }

            highlightPossibleMoves(row, col) {
                this.clearHighlights();
                
                const squares = this.chessboardEl.querySelectorAll('.square');
                squares[row * 8 + col].classList.add('selected');

                for (let toRow = 0; toRow < 8; toRow++) {
                    for (let toCol = 0; toCol < 8; toCol++) {
                        if (this.isValidMove(row, col, toRow, toCol)) {
                            squares[toRow * 8 + toCol].classList.add('possible-move');
                        }
                    }
                }
            }

            // --- De rest van de spellogica (isValidMove, makeMove, etc.) is hieronder ongewijzigd gelaten ---
            // Deze logica was al van zeer hoge kwaliteit en vereiste geen aanpassingen.
            // ... (Alle logica van isValidMove tot updateStats)
            isValidMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];
                if (!piece) return false;
                if (targetPiece && ((this.isWhitePiece(piece) && this.isWhitePiece(targetPiece)) || (this.isBlackPiece(piece) && this.isBlackPiece(targetPiece)))) {
                    return false;
                }
                if (!this.isValidPieceMove(fromRow, fromCol, toRow, toCol, piece)) {
                    return false;
                }
                return !this.wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol);
            }
            isValidPieceMove(fromRow, fromCol, toRow, toCol, piece) {
                const pieceType = piece.toLowerCase();
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                switch (pieceType) {
                    case 'p': return this.isValidPawnMove(fromRow, fromCol, toRow, toCol, piece);
                    case 'r': return (rowDiff === 0 || colDiff === 0) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'n': return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                    case 'b': return rowDiff === colDiff && rowDiff > 0 && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'q': return ((rowDiff === 0 || colDiff === 0) || (rowDiff === colDiff && rowDiff > 0)) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'k': return this.isValidKingMove(fromRow, fromCol, toRow, toCol, piece);
                    default: return false;
                }
            }
            isValidPawnMove(fromRow, fromCol, toRow, toCol, piece) {
                const direction = this.isWhitePiece(piece) ? -1 : 1;
                const startRow = this.isWhitePiece(piece) ? 6 : 1;
                const targetPiece = this.board[toRow][toCol];
                if (fromCol === toCol && !targetPiece) {
                    if (toRow === fromRow + direction) return true;
                    if (fromRow === startRow && toRow === fromRow + 2 * direction && !this.board[fromRow + direction][fromCol]) return true;
                }
                if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {
                    if (targetPiece) return true;
                    if (this.enPassantTarget && toRow === this.enPassantTarget.row && toCol === this.enPassantTarget.col) return true;
                }
                return false;
            }
            isValidKingMove(fromRow, fromCol, toRow, toCol, piece) {
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                if (rowDiff <= 1 && colDiff <= 1) return true;
                if (rowDiff === 0 && colDiff === 2) return this.canCastle(fromRow, fromCol, toRow, toCol, piece);
                return false;
            }
            canCastle(fromRow, fromCol, toRow, toCol, piece) {
                const isWhite = this.isWhitePiece(piece);
                const backRank = isWhite ? 7 : 0;
                if (fromRow !== backRank || toRow !== backRank || this.isInCheck(isWhite ? 'white' : 'black')) return false;
                const kingSide = toCol > fromCol;
                if (kingSide) {
                    if (!this.castlingRights[isWhite ? 'whiteKingSide' : 'blackKingSide']) return false;
                    for (let c = fromCol + 1; c < 7; c++) if (this.board[backRank][c] !== '') return false;
                    for (let c = fromCol; c <= fromCol + 2; c++) if (this.wouldBeUnderAttack(backRank, c, isWhite ? 'white' : 'black')) return false;
                } else {
                    if (!this.castlingRights[isWhite ? 'whiteQueenSide' : 'blackQueenSide']) return false;
                    for (let c = fromCol - 1; c > 0; c--) if (this.board[backRank][c] !== '') return false;
                    for (let c = fromCol; c >= fromCol - 2; c--) if (this.wouldBeUnderAttack(backRank, c, isWhite ? 'white' : 'black')) return false;
                }
                return true;
            }
            isPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = Math.sign(toRow - fromRow);
                const colStep = Math.sign(toCol - fromCol);
                let r = fromRow + rowStep;
                let c = fromCol + colStep;
                while (r !== toRow || c !== toCol) {
                    if (this.board[r][c] !== '') return false;
                    r += rowStep;
                    c += colStep;
                }
                return true;
            }
            wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const captured = this.board[toRow][toCol];
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = '';
                const inCheck = this.isInCheck(this.isWhitePiece(piece) ? 'white' : 'black');
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = captured;
                return inCheck;
            }
            wouldBeUnderAttack(row, col, color) {
                const opponent = color === 'white' ? 'black' : 'white';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && ((opponent === 'white' && this.isWhitePiece(piece)) || (opponent === 'black' && this.isBlackPiece(piece)))) {
                            if (this.canPieceAttack(r, c, row, col, piece)) return true;
                        }
                    }
                }
                return false;
            }
            canPieceAttack(fromRow, fromCol, toRow, toCol, piece) {
                const pieceType = piece.toLowerCase();
                const targetPiece = this.board[toRow][toCol];
                this.board[toRow][toCol] = '';
                let canAttack = false;
                switch (pieceType) {
                    case 'p':
                        const direction = this.isWhitePiece(piece) ? -1 : 1;
                        canAttack = Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction;
                        break;
                    default: canAttack = this.isValidPieceMove(fromRow, fromCol, toRow, toCol, piece);
                }
                this.board[toRow][toCol] = targetPiece;
                return canAttack;
            }
            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                const pieceType = piece.toLowerCase();
                let isEnPassant = pieceType === 'p' && !capturedPiece && Math.abs(fromCol - toCol) === 1;
                let isCastling = pieceType === 'k' && Math.abs(fromCol - toCol) === 2;
                let isPromotion = pieceType === 'p' && (toRow === 0 || toRow === 7);

                const moveData = {
                    from: { row: fromRow, col: fromCol, piece },
                    to: { row: toRow, col: toCol, piece: capturedPiece },
                    special: { isEnPassant, isCastling, isPromotion },
                    castlingRights: { ...this.castlingRights },
                    enPassantTarget: this.enPassantTarget
                };

                if (isEnPassant) {
                    const capturedPawnRow = this.isWhitePiece(piece) ? toRow + 1 : toRow - 1;
                    moveData.to.piece = this.board[capturedPawnRow][toCol];
                    this.board[capturedPawnRow][toCol] = '';
                }
                if (isCastling) {
                    const rookFromCol = toCol > fromCol ? 7 : 0;
                    const rookToCol = toCol > fromCol ? 5 : 3;
                    this.board[toRow][rookToCol] = this.board[toRow][rookFromCol];
                    this.board[toRow][rookFromCol] = '';
                }
                this.board[toRow][toCol] = isPromotion ? (this.isWhitePiece(piece) ? 'Q' : 'q') : piece;
                this.board[fromRow][fromCol] = '';
                
                const moveNotation = this.getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece, isEnPassant, isCastling, isPromotion);
                this.moves.push(moveNotation);
                this.moveHistory.push(moveData);

                this.updateCastlingRights(piece, fromRow, fromCol);
                this.enPassantTarget = pieceType === 'p' && Math.abs(fromRow - toRow) === 2 ? { row: (fromRow + toRow) / 2, col: fromCol } : null;

                this.lastMove = { fromRow, fromCol, toRow, toCol };
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.renderBoard();
                this.updateMovesList();
                this.updateGameStatus();
                this.provideFeedback(fromRow, fromCol, toRow, toCol, piece);
                if (this.isCheckmate() || this.isStalemate()) { this.gameOver = true; this.endGame(); }
            }
            updateCastlingRights(piece, fromRow, fromCol) {
                const pieceType = piece.toLowerCase();
                if (pieceType === 'k') {
                    if (this.isWhitePiece(piece)) { this.castlingRights.whiteKingSide = this.castlingRights.whiteQueenSide = false; }
                    else { this.castlingRights.blackKingSide = this.castlingRights.blackQueenSide = false; }
                }
                if (pieceType === 'r') {
                    if (fromRow === 7) {
                        if (fromCol === 0) this.castlingRights.whiteQueenSide = false;
                        if (fromCol === 7) this.castlingRights.whiteKingSide = false;
                    } else if (fromRow === 0) {
                        if (fromCol === 0) this.castlingRights.blackQueenSide = false;
                        if (fromCol === 7) this.castlingRights.blackKingSide = false;
                    }
                }
            }
            getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece, isEnPassant, isCastling, isPromotion) {
                if (isCastling) return toCol > fromCol ? 'O-O' : 'O-O-O';
                const files = 'abcdefgh';
                const toSquare = files[toCol] + (8 - toRow);
                const pieceSymbol = piece.toUpperCase() === 'P' ? '' : piece.toUpperCase();
                const capture = (capturedPiece || isEnPassant) ? (piece.toUpperCase() === 'P' ? files[fromCol] + 'x' : 'x') : '';
                let notation = `${pieceSymbol}${capture}${toSquare}`;
                if (isPromotion) notation += '=Q';
                return notation;
            }
            makeAIMove() {
                if (this.gameOver) return;
                const possibleMoves = this.getAllPossibleMoves('black');
                if (possibleMoves.length === 0) { this.gameOver = true; this.endGame(); return; }
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                this.makeMove(randomMove.fromRow, randomMove.fromCol, randomMove.toRow, randomMove.toCol);
            }
            getAllPossibleMoves(color) {
                const moves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && ((color === 'white' && this.isWhitePiece(piece)) || (color === 'black' && this.isBlackPiece(piece)))) {
                            for (let toR = 0; toR < 8; toR++) {
                                for (let toC = 0; toC < 8; toC++) {
                                    if (this.isValidMove(r, c, toR, toC)) {
                                        moves.push({ fromRow: r, fromCol: c, toRow: toR, toCol: toC, piece });
                                    }
                                }
                            }
                        }
                    }
                }
                return moves;
            }
            updateMovesList() {
                if (this.moves.length === 0) { this.movesListEl.innerHTML = '<div style="text-align: center; color: #666; font-style: italic;">Nog geen zetten gespeeld</div>'; return; }
                let html = '';
                for (let i = 0; i < this.moves.length; i += 2) {
                    html += `<div class="move-pair">${Math.floor(i / 2) + 1}. ${this.moves[i] || ''} ${this.moves[i + 1] || ''}</div>`;
                }
                this.movesListEl.innerHTML = html;
                this.movesListEl.scrollTop = this.movesListEl.scrollHeight;
            }
            provideFeedback(fromRow, fromCol, toRow, toCol, piece) {
                const captured = this.moveHistory[this.moveHistory.length - 1].to.piece;
                let msg = 'Zet gespeeld. Denk aan je ontwikkeling en veiligheid.', cls = 'feedback';
                if (captured) { msg = `Goed! Je hebt een ${this.getPieceName(captured)} geslagen.`; }
                else if (this.isGoodMove(fromRow, fromCol, toRow, toCol, piece)) { msg = 'Goede zet! Je ontwikkelt je stukken goed.'; }
                else if (this.isDangerousMove(toRow, toCol)) { msg = 'Let op! Je stuk staat nu onder aanval.'; cls += ' warning'; }
                this.feedbackEl.textContent = msg; this.feedbackEl.className = cls;
            }
            getPieceName(p) { const n = {p:'pion',r:'toren',n:'paard',b:'loper',q:'dame',k:'koning'}; return n[p.toLowerCase()]||'stuk'; }
            isGoodMove(fromRow, fromCol, toRow, toCol, piece) {
                const pt = piece.toLowerCase();
                if ((pt === 'n' || pt === 'b') && fromRow === 7) return true;
                const dist = (r, c) => Math.abs(r-3.5) + Math.abs(c-3.5);
                return dist(toRow, toCol) < dist(fromRow, fromCol);
            }
            isDangerousMove(row, col) { return this.wouldBeUnderAttack(row, col, 'white'); }
            showHint() {
                if (this.gameOver || this.currentPlayer !== 'white') return;
                const moves = this.getAllPossibleMoves('white'); if (moves.length === 0) return;
                const hint = moves[Math.floor(Math.random() * moves.length)];
                this.clearHighlights();
                const squares = this.chessboardEl.querySelectorAll('.square');
                squares[hint.fromRow * 8 + hint.fromCol].classList.add('hint');
                squares[hint.toRow * 8 + hint.toCol].classList.add('hint');
                this.feedbackEl.textContent = 'Hint: Kijk naar de gemarkeerde velden!';
                this.feedbackEl.className = 'feedback';
                setTimeout(() => this.clearHighlights(), 3000);
            }
            undoMove() {
                if (this.gameOver || this.moveHistory.length < 2) return;
                for (let i = 0; i < 2; i++) {
                    const lastMove = this.moveHistory.pop();
                    this.board[lastMove.from.row][lastMove.from.col] = lastMove.from.piece;
                    this.board[lastMove.to.row][lastMove.to.col] = lastMove.to.piece;
                    this.moves.pop();
                    if (lastMove.special.isEnPassant) {
                        const capturedPawnRow = this.isWhitePiece(lastMove.from.piece) ? lastMove.to.row + 1 : lastMove.to.row - 1;
                        this.board[capturedPawnRow][lastMove.to.col] = this.isWhitePiece(lastMove.from.piece) ? 'p' : 'P';
                    }
                    if (lastMove.special.isCastling) {
                        const rookFromCol = lastMove.to.col > lastMove.from.col ? 5 : 3;
                        const rookToCol = lastMove.to.col > lastMove.from.col ? 7 : 0;
                        this.board[lastMove.from.row][rookToCol] = this.board[lastMove.from.row][rookFromCol];
                        this.board[lastMove.from.row][rookFromCol] = '';
                    }
                    if (i === 1) { // Player move
                        this.castlingRights = lastMove.castlingRights;
                        this.enPassantTarget = lastMove.enPassantTarget;
                    }
                }
                this.currentPlayer = 'white'; this.lastMove = null;
                this.renderBoard(); this.updateMovesList(); this.updateGameStatus();
                this.feedbackEl.textContent = 'Zetten teruggedraaid. Probeer iets anders!'; this.feedbackEl.className = 'feedback';
            }
            newGame() {
                this.board = [
                    ['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'], ['','','','','','','',''], ['','','','','','','',''],
                    ['','','','','','','',''], ['','','','','','','',''], ['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R']
                ];
                this.currentPlayer = 'white'; this.selectedSquare = null; this.gameOver = false;
                this.moves = []; this.moveHistory = []; this.lastMove = null;
                this.castlingRights = { whiteKingSide: true, whiteQueenSide: true, blackKingSide: true, blackQueenSide: true };
                this.enPassantTarget = null;
                this.hintBtn.disabled = false; this.undoBtn.disabled = false;
                this.renderBoard(); this.updateMovesList(); this.updateGameStatus();
                this.feedbackEl.textContent = 'Nieuw spel gestart! Klik op een wit stuk.'; this.feedbackEl.className = 'feedback';
            }
            updateGameStatus() {
                if (this.gameOver) return;
                const status = this.isCheckmate() ? 'checkmate' : this.isStalemate() ? 'stalemate' : 'playing';
                let text = 'AI denkt na...';
                if (this.currentPlayer === 'white') text = this.isInCheck('white') ? 'Je staat schaak!' : 'Jouw beurt - Speel met wit';
                this.gameStatusEl.textContent = text;
                this.gameStatusEl.className = `game-status ${status}`;
            }
            isCheckmate() { return this.getAllPossibleMoves(this.currentPlayer).length === 0 && this.isInCheck(this.currentPlayer); }
            isStalemate() { return this.getAllPossibleMoves(this.currentPlayer).length === 0 && !this.isInCheck(this.currentPlayer); }
            isInCheck(color) {
                let kingPos;
                const kingPiece = color === 'white' ? 'K' : 'k';
                for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { if (this.board[r][c] === kingPiece) kingPos = { r, c }; } }
                return kingPos ? this.wouldBeUnderAttack(kingPos.r, kingPos.c, color) : false;
            }
            endGame() {
                let msg = '', cls = 'feedback';
                if (this.isCheckmate()) {
                    if (this.currentPlayer === 'white') { msg = 'Schaakmat! Je hebt verloren.'; cls += ' error'; }
                    else { msg = 'Schaakmat! Je hebt gewonnen!'; this.gamesWon++; }
                    this.gamesPlayed++;
                } else if (this.isStalemate()) { msg = 'Pat! Gelijkspel.'; cls += ' warning'; this.gamesPlayed++; }
                this.gameStatusEl.textContent = msg;
                this.gameStatusEl.className = `game-status ${this.isCheckmate() ? 'checkmate' : 'stalemate'}`;
                this.feedbackEl.textContent = msg + ' Klik op "Nieuw Spel".'; this.feedbackEl.className = cls;
                this.updateStats();
                this.hintBtn.disabled = true; this.undoBtn.disabled = true;
            }
            updateStats() {
                this.gamesPlayedEl.textContent = this.gamesPlayed;
                this.gamesWonEl.textContent = this.gamesWon;
                this.winRateEl.textContent = this.gamesPlayed > 0 ? `${Math.round(this.gamesWon / this.gamesPlayed * 100)}%` : '0%';
            }
        }

        // Start het spel zodra de pagina is geladen
        window.addEventListener('DOMContentLoaded', () => {
            new ChessGame();
        });
    </script>
</body>
</html>