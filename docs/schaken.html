<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eddie's Schaak Arena Pro</title>
    <style>
        /* --- Algemene Stijlen --- */
        :root {
            --primary-start: #1a2a6c;
            --primary-end: #b21f1f;
            --light-square: #eeeed2;
            --dark-square: #769656; /* Klassiek groen toernooi bord */
            --highlight-color: rgba(255, 255, 0, 0.5);
            --hint-color: #ff9800;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            align-items: start;
        }

        .game-area, .sidebar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        /* --- Header & Stats --- */
        .header h1 { text-align: center; margin-bottom: 20px; color: #1a2a6c; font-size: 2rem;}

        .status-bar {
            display: flex;
            justify-content: space-between;
            background: #f0f2f5;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        /* --- Bord --- */
        .chessboard-wrapper {
            width: 100%;
            max-width: 550px;
            margin: 0 auto 20px;
            position: relative;
        }
        
        /* Spinner voor AI denken */
        .ai-thinking {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            display: none;
            z-index: 10;
            font-weight: bold;
        }
        .ai-thinking.active { display: block; animation: pulse 1s infinite; }

        .chessboard {
            width: 100%;
            border: 5px solid #333;
            display: grid;
            /* FIX: Zowel kolommen als rijen expliciet defini√´ren */
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            user-select: none;
            background-color: #333; /* Achtergrond voor randjes */
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Responsieve tekstgrootte die binnen het vakje past */
            font-size: clamp(1.2rem, 5.5vw, 3rem);
            cursor: pointer;
            position: relative;
            line-height: 1; /* Voorkomt dat teksthoogte de layout verpest */
        }

        .square.light { background-color: var(--light-square); }
        .square.dark { background-color: var(--dark-square); }
        
        .square.selected { background-color: #bbc !important; }
        .square.last-move { background-color: rgba(255, 255, 0, 0.4) !important; }
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 25%; height: 25%;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
        }
        .square.capture-move { background-color: rgba(255, 0, 0, 0.3) !important; }

        /* --- Controls --- */
        .controls { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 20px;}
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            transition: transform 0.2s;
        }
        .btn:active { transform: scale(0.95); }
        .btn-blue { background: #007bff; }
        .btn-green { background: #28a745; }
        .btn-orange { background: #fd7e14; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }

        select { padding: 10px; border-radius: 8px; width: 100%; margin-bottom: 10px; }

        /* --- Sidebar --- */
        .moves-log {
            height: 300px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid #ddd;
            padding: 10px;
            font-family: monospace;
            margin-top: 10px;
        }
        .log-entry { display: flex; justify-content: space-between; border-bottom: 1px solid #eee; padding: 2px 0; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            .sidebar { order: 2; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="game-area">
        <header class="header">
            <h1>‚ôüÔ∏è Eddie's Schaak Arena</h1>
        </header>

        <div class="status-bar">
            <span>Jouw ELO: <span id="player-elo">1200</span></span>
            <span id="game-state">Wit aan zet</span>
            <span>AI Niveau: <span id="ai-level-display">Beginner</span></span>
        </div>

        <div class="chessboard-wrapper">
            <div id="ai-loader" class="ai-thinking">ü§ñ AI denkt na...</div>
            <div class="chessboard" id="board"></div>
        </div>

        <div class="controls">
            <select id="difficulty">
                <option value="1000">Niveau 1: Beginner (Veel fouten)</option>
                <option value="1200" selected>Niveau 2: Amateur (Af en toe foutje)</option>
                <option value="1400">Niveau 3: Clubspeler (Degelijk)</option>
                <option value="1600">Niveau 4: Expert (Denkt diep na)</option>
            </select>
        </div>
        <div class="controls">
            <button class="btn btn-orange" id="undo-btn">Herstel</button>
            <button class="btn btn-green" id="new-game-btn">Nieuw Spel</button>
        </div>
    </div>

    <aside class="sidebar">
        <h3>Partij Info</h3>
        <p id="eval-score">Evaluatie: Gelijk (0.0)</p>
        <div class="moves-log" id="moves-log"></div>
    </aside>
</div>

<script>
    /* --- CONFIGURATIE --- */
    const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    const PST = {
        p: [ [0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0] ],
        n: [ [-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50] ],
        b: [ [-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,10,10,5,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,10,10,10,10,0,-10],[-10,10,10,10,10,10,10,-10],[-10,5,0,0,0,0,5,-10],[-20,-10,-10,-10,-10,-10,-10,-20] ],
        r: [ [0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0] ],
        q: [ [-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20] ],
        k: [ [-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-20,-30,-30,-40,-40,-30,-30,-20],[-10,-20,-20,-20,-20,-20,-20,-10],[20,20,0,0,0,0,20,20],[20,30,10,0,0,10,30,20] ]
    };

    /* --- GAME CLASS --- */
    class ChessGame {
        constructor() {
            this.boardElement = document.getElementById('board');
            this.statusElement = document.getElementById('game-state');
            this.aiLoader = document.getElementById('ai-loader');
            this.movesLog = document.getElementById('moves-log');
            this.difficultySelect = document.getElementById('difficulty');
            
            this.initialBoard = [
                ['r','n','b','q','k','b','n','r'],
                ['p','p','p','p','p','p','p','p'],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['','','','','','','',''],
                ['P','P','P','P','P','P','P','P'],
                ['R','N','B','Q','K','B','N','R']
            ];
            
            this.pieceSymbols = {'K':'‚ôî','Q':'‚ôï','R':'‚ôñ','B':'‚ôó','N':'‚ôò','P':'‚ôô','k':'‚ôö','q':'‚ôõ','r':'‚ôú','b':'‚ôù','n':'‚ôû','p':'‚ôü'};
            this.reset();
            this.bindEvents();
        }

        reset() {
            this.board = JSON.parse(JSON.stringify(this.initialBoard));
            this.turn = 'white';
            this.history = [];
            this.selectedSquare = null;
            this.gameOver = false;
            this.movesList = [];
            this.render();
            this.updateStatus();
            this.movesLog.innerHTML = '';
        }

        bindEvents() {
            this.boardElement.addEventListener('click', (e) => {
                // Voorkom klikken als het spel voorbij is of als AI denkt
                if (this.gameOver || this.turn === 'black') return;

                const square = e.target.closest('.square');
                if (!square) return;

                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);
                this.handleSquareClick(r, c);
            });

            document.getElementById('new-game-btn').addEventListener('click', () => this.reset());
            document.getElementById('undo-btn').addEventListener('click', () => this.undo());
            this.difficultySelect.addEventListener('change', () => {
                document.getElementById('ai-level-display').innerText = this.difficultySelect.options[this.difficultySelect.selectedIndex].text.split(':')[0];
            });
        }

        handleSquareClick(r, c) {
            const piece = this.board[r][c];
            const isWhitePiece = piece && piece === piece.toUpperCase();

            // 1. Als we al een selectie hebben en op een geldige zet klikken
            if (this.selectedSquare) {
                const moves = this.getLegalMoves(this.selectedSquare.r, this.selectedSquare.c);
                const move = moves.find(m => m.toR === r && m.toC === c);
                
                if (move) {
                    this.executeMove(move);
                    this.render();
                    
                    if (!this.gameOver) {
                        // BELANGRIJK: setTimeout voorkomt dat UI vastloopt
                        this.aiLoader.classList.add('active');
                        setTimeout(() => this.makeAIMove(), 50);
                    }
                    return;
                }
            }

            // 2. Selecteer een nieuw stuk (alleen wit)
            if (isWhitePiece) {
                this.selectedSquare = {r, c};
                this.render(); // Update highlights
            } else {
                this.selectedSquare = null;
                this.render();
            }
        }

        executeMove(move) {
            const piece = this.board[move.fromR][move.fromC];
            const target = this.board[move.toR][move.toC];
            
            // Opslaan voor undo
            this.history.push({
                board: JSON.parse(JSON.stringify(this.board)),
                turn: this.turn,
                movesList: [...this.movesList],
                gameOver: this.gameOver
            });

            // Voer zet uit
            this.board[move.toR][move.toC] = piece;
            this.board[move.fromR][move.fromC] = '';

            // Promotie (simpel: altijd dame)
            if (piece === 'P' && move.toR === 0) this.board[move.toR][move.toC] = 'Q';
            if (piece === 'p' && move.toR === 7) this.board[move.toR][move.toC] = 'q';

            // Log de zet
            const notation = `${this.getColName(move.fromC)}${8-move.fromR} ‚Üí ${this.getColName(move.toC)}${8-move.toR}`;
            this.logMove(notation, this.turn);

            // Wissel beurt
            this.turn = this.turn === 'white' ? 'black' : 'white';
            this.selectedSquare = null;
            
            this.checkGameState();
            this.updateStatus();
        }

        undo() {
            if (this.history.length < 2) return; // Moet minimaal 1 volledige beurt terug (wit + zwart)
            // Ga 2 stappen terug (wit zet, zwart zet)
            const prevState = this.history[this.history.length - 2];
            this.board = prevState.board;
            this.turn = prevState.turn;
            this.movesList = prevState.movesList;
            this.gameOver = prevState.gameOver;
            this.history.pop(); // Remove black move
            this.history.pop(); // Remove white move
            
            this.movesLog.innerHTML = '';
            this.movesList.forEach((m, i) => this.logMove(m.text, i % 2 === 0 ? 'white' : 'black'));
            
            this.render();
            this.updateStatus();
        }

        makeAIMove() {
            const start = performance.now();
            const difficulty = parseInt(this.difficultySelect.value);
            
            // Instellingen per niveau
            let depth = 2; // Default
            let blunderChance = 0.0; // Kans op willekeurige slechte zet

            if (difficulty === 1000) { depth = 1; blunderChance = 0.35; }
            else if (difficulty === 1200) { depth = 2; blunderChance = 0.1; }
            else if (difficulty === 1400) { depth = 3; blunderChance = 0.02; }
            else if (difficulty === 1600) { depth = 3; blunderChance = 0.0; } // Expert

            let bestMove = null;
            const legalMoves = this.getAllLegalMoves('black');

            if (legalMoves.length === 0) {
                this.aiLoader.classList.remove('active');
                return;
            }

            // Blunder logica voor laag niveau
            if (Math.random() < blunderChance) {
                bestMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                console.log("AI blunder!");
            } else {
                // Minimax berekening
                let bestVal = -Infinity;
                
                // Sorteer zetten (slagzetten eerst) voor betere pruning
                this.orderMoves(legalMoves);

                for (let move of legalMoves) {
                    // Simuleer zet
                    const savedBoard = JSON.parse(JSON.stringify(this.board));
                    this.makeTempMove(move);
                    
                    const val = this.minimax(depth - 1, -Infinity, Infinity, false);
                    
                    // Draai zet terug
                    this.board = savedBoard;

                    if (val > bestVal) {
                        bestVal = val;
                        bestMove = move;
                    }
                }
                
                // Update evaluatie display
                document.getElementById('eval-score').innerText = `Evaluatie: ${bestVal / 100}`;
            }

            this.aiLoader.classList.remove('active');
            
            if (bestMove) {
                this.executeMove(bestMove);
                this.render();
            } else {
                // Pat of mat situatie die hierboven niet gevangen is
                this.gameOver = true;
                this.statusElement.innerText = "Spel voorbij";
            }
        }

        /* --- AI LOGICA (Minimax + Alpha Beta) --- */
        minimax(depth, alpha, beta, isMaximizing) {
            if (depth === 0) return this.evaluateBoard();

            const moves = this.getAllLegalMoves(isMaximizing ? 'black' : 'white');
            if (moves.length === 0) {
                // Geen zetten? Check of koning schaak staat (mat) of niet (pat)
                // Voor snelheid: geef gewoon een hoge/lage score
                return isMaximizing ? -99999 : 99999; 
            }

            this.orderMoves(moves);

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of moves) {
                    const saved = JSON.parse(JSON.stringify(this.board));
                    this.makeTempMove(move);
                    const evalScore = this.minimax(depth - 1, alpha, beta, false);
                    this.board = saved;
                    maxEval = Math.max(maxEval, evalScore);
                    alpha = Math.max(alpha, evalScore);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of moves) {
                    const saved = JSON.parse(JSON.stringify(this.board));
                    this.makeTempMove(move);
                    const evalScore = this.minimax(depth - 1, alpha, beta, true);
                    this.board = saved;
                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        evaluateBoard() {
            let score = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = this.board[r][c];
                    if (!piece) continue;
                    
                    const type = piece.toLowerCase();
                    const val = PIECE_VALUES[type];
                    // PST omdraaien voor zwart (rij 7 wordt rij 0)
                    const pst = piece === piece.toUpperCase() ? 
                        PST[type][r][c] : 
                        PST[type][7-r][c]; // Simpele flip

                    if (piece === piece.toUpperCase()) {
                        score -= (val + pst); // Wit negatief voor algoritme (want AI is zwart/max)
                    } else {
                        score += (val + pst); // Zwart positief
                    }
                }
            }
            return score;
        }

        orderMoves(moves) {
            // Sorteer: zetten die iets slaan komen eerst. Dit versnelt de AI enorm.
            moves.sort((a, b) => {
                const captureA = this.board[a.toR][a.toC] !== '' ? 10 : 0;
                const captureB = this.board[b.toR][b.toC] !== '' ? 10 : 0;
                return captureB - captureA;
            });
        }

        makeTempMove(move) {
            this.board[move.toR][move.toC] = this.board[move.fromR][move.fromC];
            this.board[move.fromR][move.fromC] = '';
            // Promotie logica voor temp moves
            if (this.board[move.toR][move.toC] === 'P' && move.toR === 0) this.board[move.toR][move.toC] = 'Q';
            if (this.board[move.toR][move.toC] === 'p' && move.toR === 7) this.board[move.toR][move.toC] = 'q';
        }

        /* --- REGELS & HULP --- */
        getAllLegalMoves(color) {
            let moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = this.board[r][c];
                    if (!piece) continue;
                    if ((color === 'white' && piece === piece.toUpperCase()) ||
                        (color === 'black' && piece === piece.toLowerCase())) {
                        moves = moves.concat(this.getLegalMoves(r, c));
                    }
                }
            }
            return moves;
        }

        getLegalMoves(r, c) {
            const piece = this.board[r][c];
            if (!piece) return [];
            
            const type = piece.toLowerCase();
            const moves = [];
            const directions = {
                n: [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]],
                b: [[-1,-1],[-1,1],[1,-1],[1,1]],
                r: [[-1,0],[1,0],[0,-1],[0,1]],
                q: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]],
                k: [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]]
            };

            const isWhite = piece === piece.toUpperCase();

            // PION
            if (type === 'p') {
                const dir = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                
                // 1 stap
                if (this.isEmpty(r + dir, c)) {
                    moves.push({fromR: r, fromC: c, toR: r + dir, toC: c});
                    // 2 stappen
                    if (r === startRow && this.isEmpty(r + (dir * 2), c)) {
                        moves.push({fromR: r, fromC: c, toR: r + (dir * 2), toC: c});
                    }
                }
                // Slaan
                if (this.isEnemy(r + dir, c - 1, isWhite)) moves.push({fromR: r, fromC: c, toR: r + dir, toC: c - 1});
                if (this.isEnemy(r + dir, c + 1, isWhite)) moves.push({fromR: r, fromC: c, toR: r + dir, toC: c + 1});
            } 
            else {
                // ANDERE STUKKEN
                const dirs = directions[type];
                const infinite = (type === 'b' || type === 'r' || type === 'q');
                
                for (let d of dirs) {
                    let nr = r + d[0], nc = c + d[1];
                    while (this.isOnBoard(nr, nc)) {
                        if (this.isEmpty(nr, nc)) {
                            moves.push({fromR: r, fromC: c, toR: nr, toC: nc});
                        } else {
                            if (this.isEnemy(nr, nc, isWhite)) {
                                moves.push({fromR: r, fromC: c, toR: nr, toC: nc});
                            }
                            break; // Blokkeert
                        }
                        if (!infinite) break;
                        nr += d[0]; nc += d[1];
                    }
                }
            }

            // FILTER: Koning mag niet schaak staan na zet
            return moves.filter(m => {
                const saved = JSON.parse(JSON.stringify(this.board));
                this.makeTempMove(m);
                // Zoek koning
                let kingPos = null;
                const myKing = isWhite ? 'K' : 'k';
                for(let i=0; i<8; i++) for(let j=0; j<8; j++) if(this.board[i][j] === myKing) kingPos = {r:i, c:j};
                
                // Simpele check: wordt koning aangevallen?
                // Voor performance skippen we soms diepe checks in JS, maar dit is nodig voor legale zetten
                const inCheck = this.isSquareAttacked(kingPos.r, kingPos.c, !isWhite);
                this.board = saved;
                return !inCheck;
            });
        }

        isSquareAttacked(r, c, byWhite) {
            // Eenvoudige check: kan een vijandig stuk naar (r,c) bewegen?
            // Dit is 'duur', we doen een reverse check (kan een paard op r,c een vijandig paard slaan?)
            
            // 1. Pionnen
            const pawnDir = byWhite ? 1 : -1; // Vijandige pion komt van andere kant
            if (this.isPiece(r + pawnDir, c - 1, byWhite ? 'P' : 'p')) return true;
            if (this.isPiece(r + pawnDir, c + 1, byWhite ? 'P' : 'p')) return true;

            // 2. Paarden
            const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for (let m of knightMoves) if (this.isPiece(r+m[0], c+m[1], byWhite ? 'N' : 'n')) return true;

            // 3. Koning
            for (let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) if(i||j) if(this.isPiece(r+i, c+j, byWhite ? 'K' : 'k')) return true;

            // 4. Glijders (Loper/Toren/Dame)
            const lines = [
                {dr: -1, dc: 0, p: ['R','Q']}, {dr: 1, dc: 0, p: ['R','Q']},
                {dr: 0, dc: -1, p: ['R','Q']}, {dr: 0, dc: 1, p: ['R','Q']},
                {dr: -1, dc: -1, p: ['B','Q']}, {dr: -1, dc: 1, p: ['B','Q']},
                {dr: 1, dc: -1, p: ['B','Q']}, {dr: 1, dc: 1, p: ['B','Q']}
            ];

            for (let line of lines) {
                let nr = r + line.dr, nc = c + line.dc;
                while (this.isOnBoard(nr, nc)) {
                    const p = this.board[nr][nc];
                    if (p !== '') {
                        if ((byWhite && p === p.toUpperCase()) || (!byWhite && p === p.toLowerCase())) {
                            const type = p.toUpperCase();
                            if (line.p.includes(type)) return true;
                        }
                        break;
                    }
                    nr += line.dr; nc += line.dc;
                }
            }
            return false;
        }

        isPiece(r, c, type) {
            return this.isOnBoard(r, c) && this.board[r][c] === type;
        }

        isOnBoard(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }
        isEmpty(r, c) { return this.isOnBoard(r, c) && this.board[r][c] === ''; }
        isEnemy(r, c, isWhite) {
            if (!this.isOnBoard(r, c) || this.board[r][c] === '') return false;
            const p = this.board[r][c];
            return isWhite ? p === p.toLowerCase() : p === p.toUpperCase();
        }

        /* --- VISUALS --- */
        render() {
            this.boardElement.innerHTML = '';
            let legalMovesForSelected = [];
            if (this.selectedSquare) {
                legalMovesForSelected = this.getLegalMoves(this.selectedSquare.r, this.selectedSquare.c);
            }

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;

                    // Stuk tonen
                    const piece = this.board[r][c];
                    if (piece) square.innerText = this.pieceSymbols[piece];

                    // Highlights
                    if (this.selectedSquare && this.selectedSquare.r === r && this.selectedSquare.c === c) {
                        square.classList.add('selected');
                    }
                    
                    // Possible moves
                    const move = legalMovesForSelected.find(m => m.toR === r && m.toC === c);
                    if (move) {
                        square.classList.add('possible-move');
                        if (piece) square.classList.add('capture-move');
                    }

                    // Laatste zet highlight
                    if (this.history.length > 0) {
                        const last = this.history[this.history.length - 1];
                        // Dit vereist wat meer logica om from/to uit history te halen, 
                        // voor nu simpel houden voor performance.
                    }

                    this.boardElement.appendChild(square);
                }
            }
        }

        updateStatus() {
            if (this.gameOver) {
                this.statusElement.innerText = `Game Over! ${this.turn === 'white' ? 'Zwart' : 'Wit'} wint.`;
                this.statusElement.style.color = 'red';
            } else {
                this.statusElement.innerText = `${this.turn === 'white' ? 'Jij bent' : 'AI is'} aan zet`;
                this.statusElement.style.color = 'inherit';
            }
        }

        checkGameState() {
            const legalMoves = this.getAllLegalMoves(this.turn);
            if (legalMoves.length === 0) {
                // Check of mat of pat
                // Hier simpelweg game over
                this.gameOver = true;
            }
        }

        logMove(text, turn) {
            this.movesList.push({text, turn});
            const div = document.createElement('div');
            div.className = 'log-entry';
            const num = Math.ceil(this.movesList.length);
            div.innerHTML = `<span>${num}. ${turn === 'white' ? 'Wit' : 'Zwart'}</span> <span>${text}</span>`;
            this.movesLog.prepend(div);
        }

        getColName(c) { return String.fromCharCode(97 + c); }
    }

    // Start de game
    window.addEventListener('DOMContentLoaded', () => {
        const game = new ChessGame();
    });
</script>

</body>
</html>




