<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verbeterde Schaak Training App</title>
    <style>
        /* --- Algemene Stijlen --- */
        :root {
            --primary-start: #667eea;
            --primary-end: #764ba2;
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --border-color: #8B4513;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --error-color: #dc3545;
            --highlight-color: #4caf50;
            --hint-color: #ff9800;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* VERBETERING: Verwijdert de blauwe highlight bij aanraking op mobiel */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--primary-start) 0%, var(--primary-end) 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        /* --- Layout --- */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            align-items: start;
        }

        .game-area, .sidebar {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .sidebar {
            height: fit-content;
        }

        /* --- Header & ELO --- */
        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .elo-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .elo-item {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            color: #333;
            padding: 15px 25px;
            border-radius: 15px;
            text-align: center;
            font-weight: bold;
            flex: 1;
            max-width: 200px;
            position: relative;
        }
        
        .elo-change {
            position: absolute;
            top: -10px;
            right: -10px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
        }

        .elo-change.gain { background-color: var(--success-color); }
        .elo-change.loss { background-color: var(--error-color); }
        .elo-change.show { opacity: 1; transform: translateY(-5px); }


        .elo-item span {
            display: block;
            font-size: 1.8rem;
            margin-bottom: 5px;
            color: var(--primary-end);
        }
        
        /* --- Schaakbord --- */
        .chessboard-wrapper {
            width: 100%;
            max-width: 600px; /* Groter bord op desktop */
            margin: 0 auto 20px;
            position: relative;
        }
        
        .chessboard {
            width: 100%;
            border: 4px solid var(--border-color);
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            aspect-ratio: 1 / 1; /* Zorgt ervoor dat het bord altijd vierkant blijft */
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            /* VERBETERING: Stukken schalen nu perfect mee met het bord */
            font-size: clamp(1rem, 9.5vmin, 3.5rem); 
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            position: relative;
        }

        .square.light { background-color: var(--light-square); }
        .square.dark { background-color: var(--dark-square); }
        .square:hover { box-shadow: inset 0 0 0 3px var(--warning-color); }
        .square.selected { box-shadow: inset 0 0 0 4px var(--highlight-color) !important; }
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.2);
        }
        .square.last-move { background-color: rgba(255, 235, 59, 0.4) !important; }
        .square.hint {
            box-shadow: inset 0 0 0 4px var(--hint-color) !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* --- Knoppen en Controls --- */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, var(--primary-start), var(--primary-end));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            flex-grow: 1; /* Knoppen groeien mee */
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .level-selector select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
            width: 100%;
            max-width: 300px;
        }

        /* --- Sidebar --- */
        .sidebar h3 {
            margin-bottom: 15px;
            font-size: 1.3rem;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }

        .feedback {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid var(--success-color);
            min-height: 50px;
        }

        .feedback.warning { border-left-color: var(--warning-color); background: #fff8e1; }
        .feedback.error { border-left-color: var(--error-color); background: #ffebee; }

        .moves-list {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .move-pair { margin-bottom: 8px; }

        .game-status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .game-status.playing { background: #e3f2fd; color: #1976d2; }
        .game-status.checkmate { background: #ffebee; color: #c62828; }
        .game-status.stalemate { background: #fff3e0; color: #ef6c00; }

        /* --- Media Queries (Responsive Design) --- */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .sidebar { order: 3; }
        }
        
        @media (max-width: 768px) {
            body { padding: 10px; }
            .game-area, .sidebar { padding: 20px 15px; }
            .header h1 { font-size: 2rem; }
            .elo-display { flex-direction: column; gap: 10px; align-items: center; }
            .elo-item { max-width: 280px; width: 100%;}
            .chessboard-wrapper { width: 100%; }
        }

        /* VERBETERING: Betere layout voor de smalste mobiele schermen */
        @media (max-width: 480px) {
            body { padding: 5px; }
            .game-area, .sidebar { padding: 15px 10px; border-radius: 15px; }
            .header h1 { font-size: 1.8rem; }
            .game-controls { flex-direction: column; }
            .btn { width: 100%; padding: 14px 20px; }
            .level-selector select { width: 100%; max-width: none;}
        }
    </style>
</head>
<body>
    <main class="container">
        <!-- Spelgedeelte -->
        <section class="game-area">
            <header class="header">
                <h1>♔ Schaak Training ♛</h1>
                <div class="elo-display">
                    <div class="elo-item">
                        <span id="current-elo">1200</span>
                        <div>Jouw ELO <div id="elo-change-indicator" class="elo-change"></div></div>
                    </div>
                    <div class="elo-item">
                        <span id="target-elo">1200</span>
                        <div>Tegenstander</div>
                    </div>
                </div>
                <div class="level-selector">
                    <select id="difficulty">
                        <option value="1000">Beginner (1000)</option>
                        <option value="1200" selected>Gevorderd Beginner (1200)</option>
                        <option value="1400">Intermediate (1400)</option>
                        <option value="1600">Gevorderd (1600)</option>
                        <option value="1800">Expert (1800)</option>
                    </select>
                </div>
            </header>

            <div class="game-status playing" id="game-status">
                Jouw beurt - Speel met wit
            </div>

            <div class="chessboard-wrapper">
                <div class="chessboard" id="chessboard"></div>
            </div>

            <div class="game-controls">
                <button class="btn" id="hint-btn">💡 Hint</button>
                <button class="btn" id="undo-btn">↶ Zet terug</button>
                <button class="btn" id="new-game-btn">🎮 Nieuw spel</button>
            </div>
        </section>

        <!-- Zijbalk met informatie -->
        <aside class="sidebar">
            <div class="game-info">
                <h3>🎯 Feedback</h3>
                <div class="feedback" id="feedback">
                    Welkom! Selecteer een moeilijkheidsgraad en start een nieuw spel.
                </div>

                <h3>📝 Zetten</h3>
                <div class="moves-list" id="moves-list">
                    <div style="text-align: center; color: #666; font-style: italic;">
                        Nog geen zetten gespeeld
                    </div>
                </div>

                <h3>📊 Voortgang</h3>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                    <div style="margin-bottom: 10px;">
                        <strong>Gespeelde partijen:</strong> <span id="games-played">0</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>Gewonnen:</strong> <span id="games-won">0</span>
                    </div>
                    <div>
                        <strong>Win percentage:</strong> <span id="win-rate">0%</span>
                    </div>
                </div>
            </div>
        </aside>
    </main>

    <script>
        class ChessGame {
            constructor() {
                this.cacheDOMElements();
                
                this.initializeConstants();
                // FIX: Initialize the squareElements array here, only once.
                this.squareElements = [];
                this.initializeState();
                
                this.createBoardDOM();
                this.updateBoard();

                this.updateGameStatus();
                this.setupEventListeners();
                this.updateEloDisplay();
            }

            initializeConstants() {
                this.pieceValues = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000 };

                const pawnPST = [
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [50, 50, 50, 50, 50, 50, 50, 50],
                    [10, 10, 20, 30, 30, 20, 10, 10],
                    [5, 5, 10, 25, 25, 10, 5, 5],
                    [0, 0, 0, 20, 20, 0, 0, 0],
                    [5, -5, -10, 0, 0, -10, -5, 5],
                    [5, 10, 10, -20, -20, 10, 10, 5],
                    [0, 0, 0, 0, 0, 0, 0, 0]
                ];
                const knightPST = [
                    [-50, -40, -30, -30, -30, -30, -40, -50],
                    [-40, -20, 0, 0, 0, 0, -20, -40],
                    [-30, 0, 10, 15, 15, 10, 0, -30],
                    [-30, 5, 15, 20, 20, 15, 5, -30],
                    [-30, 0, 15, 20, 20, 15, 0, -30],
                    [-30, 5, 10, 15, 15, 10, 5, -30],
                    [-40, -20, 0, 5, 5, 0, -20, -40],
                    [-50, -40, -30, -30, -30, -30, -40, -50]
                ];
                const bishopPST = [
                    [-20, -10, -10, -10, -10, -10, -10, -20],
                    [-10, 0, 0, 0, 0, 0, 0, -10],
                    [-10, 0, 5, 10, 10, 5, 0, -10],
                    [-10, 5, 5, 10, 10, 5, 5, -10],
                    [-10, 0, 10, 10, 10, 10, 0, -10],
                    [-10, 10, 10, 10, 10, 10, 10, -10],
                    [-10, 5, 0, 0, 0, 0, 5, -10],
                    [-20, -10, -10, -10, -10, -10, -10, -20]
                ];
                const rookPST = [
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [5, 10, 10, 10, 10, 10, 10, 5],
                    [-5, 0, 0, 0, 0, 0, 0, -5],
                    [-5, 0, 0, 0, 0, 0, 0, -5],
                    [-5, 0, 0, 0, 0, 0, 0, -5],
                    [-5, 0, 0, 0, 0, 0, 0, -5],
                    [-5, 0, 0, 0, 0, 0, 0, -5],
                    [0, 0, 0, 5, 5, 0, 0, 0]
                ];
                const queenPST = [
                    [-20, -10, -10, -5, -5, -10, -10, -20],
                    [-10, 0, 0, 0, 0, 0, 0, -10],
                    [-10, 0, 5, 5, 5, 5, 0, -10],
                    [-5, 0, 5, 5, 5, 5, 0, -5],
                    [0, 0, 5, 5, 5, 5, 0, -5],
                    [-10, 5, 5, 5, 5, 5, 0, -10],
                    [-10, 0, 5, 0, 0, 0, 0, -10],
                    [-20, -10, -10, -5, -5, -10, -10, -20]
                ];
                const kingPST = [
                    [-30, -40, -40, -50, -50, -40, -40, -30],
                    [-30, -40, -40, -50, -50, -40, -40, -30],
                    [-30, -40, -40, -50, -50, -40, -40, -30],
                    [-30, -40, -40, -50, -50, -40, -40, -30],
                    [-20, -30, -30, -40, -40, -30, -30, -20],
                    [-10, -20, -20, -20, -20, -20, -20, -10],
                    [20, 20, 0, 0, 0, 0, 20, 20],
                    [20, 30, 10, 0, 0, 10, 30, 20]
                ];
                
                this.pieceSquareTables = {
                    'P': pawnPST, 'p': this.flipPST(pawnPST),
                    'N': knightPST, 'n': this.flipPST(knightPST),
                    'B': bishopPST, 'b': this.flipPST(bishopPST),
                    'R': rookPST, 'r': this.flipPST(rookPST),
                    'Q': queenPST, 'q': this.flipPST(queenPST),
                    'K': kingPST, 'k': this.flipPST(kingPST)
                };
            }
            
            flipPST(table) {
                return table.slice().reverse();
            }

            initializeState() {
                this.board = [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
                
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.gameOver = false;
                this.moves = [];
                this.moveHistory = [];
                this.lastMove = null;
                
                this.difficulty = parseInt(this.difficultySelector.value);
                this.playerElo = 1200;
                this.gamesPlayed = 0;
                this.gamesWon = 0;
                
                this.castlingRights = {
                    whiteKingSide: true, whiteQueenSide: true,
                    blackKingSide: true, blackQueenSide: true
                };
                
                this.enPassantTarget = null;
                // FIX: Do not clear the squareElements array here.
            }

            cacheDOMElements() {
                this.chessboardEl = document.getElementById('chessboard');
                this.feedbackEl = document.getElementById('feedback');
                this.movesListEl = document.getElementById('moves-list');
                this.gameStatusEl = document.getElementById('game-status');
                this.targetEloEl = document.getElementById('target-elo');
                this.currentEloEl = document.getElementById('current-elo');
                this.eloChangeEl = document.getElementById('elo-change-indicator');
                this.gamesPlayedEl = document.getElementById('games-played');
                this.gamesWonEl = document.getElementById('games-won');
                this.winRateEl = document.getElementById('win-rate');
                this.hintBtn = document.getElementById('hint-btn');
                this.undoBtn = document.getElementById('undo-btn');
                this.newGameBtn = document.getElementById('new-game-btn');
                this.difficultySelector = document.getElementById('difficulty');
            }

            setupEventListeners() {
                this.difficultySelector.addEventListener('change', (e) => {
                    this.difficulty = parseInt(e.target.value);
                    this.targetEloEl.textContent = this.difficulty;
                    this.newGame();
                });
                
                this.hintBtn.addEventListener('click', () => this.showHint());
                this.undoBtn.addEventListener('click', () => this.undoMove());
                this.newGameBtn.addEventListener('click', () => this.newGame());

                this.chessboardEl.onclick = (e) => {
                    const squareEl = e.target.closest('.square');
                    if (squareEl) {
                        const row = parseInt(squareEl.dataset.row);
                        const col = parseInt(squareEl.dataset.col);
                        this.handleSquareClick(row, col);
                    }
                };
            }
            
            newGame() {
                this.initializeState();
                this.updateBoard();
                this.updateMovesList();
                this.updateGameStatus();
                this.updateEloDisplay();
                this.feedbackEl.textContent = 'Nieuw spel gestart! Speel met wit.';
                this.feedbackEl.className = 'feedback';
                this.hintBtn.disabled = false;
                this.undoBtn.disabled = false;
            }

            // --- AI Logic ---

            evaluateBoard(board) {
                let totalEvaluation = 0;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            const pieceValue = this.pieceValues[piece.toLowerCase()];
                            const pstValue = this.pieceSquareTables[piece][row][col];
                            const evaluation = pieceValue + pstValue;
                            totalEvaluation += this.isWhitePiece(piece) ? evaluation : -evaluation;
                        }
                    }
                }
                
                totalEvaluation += this.getAllPossibleMoves('white', board).length;
                totalEvaluation -= this.getAllPossibleMoves('black', board).length;
                
                return totalEvaluation;
            }
            
            minimax(board, depth, alpha, beta, maximizingPlayer, currentCastlingRights, currentEnPassantTarget) {
                if (depth === 0 || this.isGameOver(board, maximizingPlayer ? 'black' : 'white', currentCastlingRights, currentEnPassantTarget)) {
                    return this.evaluateBoard(board);
                }

                const moves = this.getAllPossibleMoves(maximizingPlayer ? 'black' : 'white', board, currentCastlingRights, currentEnPassantTarget);
                
                if (maximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of moves) {
                        const { newBoard, newCastlingRights, newEnPassantTarget } = this.getNewBoardState(board, move, currentCastlingRights, currentEnPassantTarget);
                        const evaluation = this.minimax(newBoard, depth - 1, alpha, beta, false, newCastlingRights, newEnPassantTarget);
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        if (beta <= alpha) break;
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of moves) {
                        const { newBoard, newCastlingRights, newEnPassantTarget } = this.getNewBoardState(board, move, currentCastlingRights, currentEnPassantTarget);
                        const evaluation = this.minimax(newBoard, depth - 1, alpha, beta, true, newCastlingRights, newEnPassantTarget);
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            }
            
            findBestMove(player) {
                const depthMap = { 1000: 1, 1200: 2, 1400: 3, 1600: 4, 1800: 4 };
                const depth = depthMap[this.difficulty] || 2;
                
                let bestMove = null;
                let bestValue = player === 'black' ? -Infinity : Infinity;
                const possibleMoves = this.getAllPossibleMoves(player, this.board);
                
                for (const move of possibleMoves) {
                    const { newBoard, newCastlingRights, newEnPassantTarget } = this.getNewBoardState(this.board, move, this.castlingRights, this.enPassantTarget);
                    const boardValue = this.minimax(newBoard, depth - 1, -Infinity, Infinity, player !== 'black', newCastlingRights, newEnPassantTarget);

                    if (player === 'black') {
                        if (boardValue > bestValue) {
                            bestValue = boardValue;
                            bestMove = move;
                        }
                    } else {
                        if (boardValue < bestValue) {
                            bestValue = boardValue;
                            bestMove = move;
                        }
                    }
                }
                return bestMove;
            }

            makeAIMove() {
                if (this.gameOver) return;
                
                if (this.difficulty === 1000 && Math.random() < 0.4) {
                    const possibleMoves = this.getAllPossibleMoves('black');
                    if (possibleMoves.length > 0) {
                        const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        this.makeMove(randomMove.fromRow, randomMove.fromCol, randomMove.toRow, randomMove.toCol);
                        return;
                    }
                }
                
                const bestMove = this.findBestMove('black');
                if (bestMove) {
                    this.makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                } else {
                    this.gameOver = true;
                    this.endGame();
                }
            }
            
            // --- ELO System ---
            updateElo(playerWon) {
                const K = 32;
                const opponentElo = this.difficulty;
                const expectedScore = 1 / (1 + Math.pow(10, (opponentElo - this.playerElo) / 400));
                let actualScore = (playerWon === true) ? 1 : (playerWon === false) ? 0 : 0.5;
                const eloChange = Math.round(K * (actualScore - expectedScore));
                this.playerElo = Math.max(800, Math.min(2200, this.playerElo + eloChange));
                this.showEloChange(eloChange);
                this.updateEloDisplay();
            }
            
            updateEloDisplay() {
                this.currentEloEl.textContent = this.playerElo;
                this.targetEloEl.textContent = this.difficulty;
            }

            showEloChange(change) {
                this.eloChangeEl.textContent = (change > 0 ? '+' : '') + change;
                this.eloChangeEl.className = `elo-change ${change >= 0 ? 'gain' : 'loss'}`;
                setTimeout(() => this.eloChangeEl.classList.add('show'), 100);
                setTimeout(() => this.eloChangeEl.classList.remove('show'), 4000);
            }
            
            // --- Hint Function ---
            showHint() {
                if (this.gameOver || this.currentPlayer !== 'white') return;
                const hintMove = this.findBestMove('white');
                if (!hintMove) return;
                this.clearHighlights();
                const squares = this.chessboardEl.querySelectorAll('.square');
                squares[hintMove.fromRow * 8 + hintMove.fromCol].classList.add('hint');
                squares[hintMove.toRow * 8 + hintMove.toCol].classList.add('hint');
                this.feedbackEl.textContent = 'Hint: De AI suggereert de gemarkeerde zet.';
                this.feedbackEl.className = 'feedback';
                setTimeout(() => this.clearHighlights(), 4000);
            }
            
            endGame() {
                let msg = '', cls = 'feedback', playerWon = null;
                if (this.isCheckmate()) {
                    if (this.currentPlayer === 'white') {
                        msg = 'Schaakmat! Je hebt verloren.'; cls += ' error'; playerWon = false;
                    } else {
                        msg = 'Schaakmat! Je hebt gewonnen!'; this.gamesWon++; playerWon = true;
                    }
                } else if (this.isStalemate()) {
                    msg = 'Pat! Gelijkspel.'; cls += ' warning'; playerWon = 'draw';
                }
                
                if (playerWon !== null) {
                    this.gamesPlayed++;
                    this.updateElo(playerWon);
                    this.updateStats();
                }

                this.gameStatusEl.textContent = msg;
                this.gameStatusEl.className = `game-status ${this.isCheckmate() ? 'checkmate' : 'stalemate'}`;
                this.feedbackEl.textContent = msg + ' Klik op "Nieuw Spel".';
                this.feedbackEl.className = cls;
                
                this.hintBtn.disabled = true;
                this.undoBtn.disabled = true;
            }
            
            updateStats() {
                this.gamesPlayedEl.textContent = this.gamesPlayed;
                this.gamesWonEl.textContent = this.gamesWon;
                this.winRateEl.textContent = this.gamesPlayed > 0 ? `${Math.round(this.gamesWon / this.gamesPlayed * 100)}%` : '0%';
            }

            // --- Core Game Logic ---

            createBoardDOM() {
                this.chessboardEl.innerHTML = '';
                // FIX: Clear the array before repopulating, only if it's necessary to recreate the DOM.
                // In this setup, it's only called once, so this is safe.
                this.squareElements = []; 
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.dataset.row = row;
                        square.dataset.col = col;
                        this.chessboardEl.appendChild(square);
                        this.squareElements.push(square);
                    }
                }
            }

            updateBoard() {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = this.squareElements[row * 8 + col];
                        
                        const colorClass = (row + col) % 2 === 0 ? 'light' : 'dark';
                        let classes = `square ${colorClass}`;
                        
                        if (this.lastMove && ((row === this.lastMove.fromRow && col === this.lastMove.fromCol) || (row === this.lastMove.toRow && col === this.lastMove.toCol))) {
                           classes += ' last-move';
                        }
                        square.className = classes;
            
                        const piece = this.board[row][col];
                        square.textContent = piece ? this.getPieceSymbol(piece) : '';
                    }
                }
            }
            
            getPieceSymbol(piece) {
                const symbols = {'K':'♔','Q':'♕','R':'♖','B':'♗','N':'♘','P':'♙','k':'♚','q':'♛','r':'♜','b':'♝','n':'➞','p':'♟'};
                return symbols[piece] || '';
            }
            
            handleSquareClick(row, col) {
                if (this.gameOver || this.currentPlayer !== 'white') return;
                const piece = this.board[row][col];
                
                if (this.selectedSquare) {
                    if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col, this.board)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                        this.selectedSquare = null;
                        this.clearHighlights();
                        if (!this.gameOver) {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    } else if (piece && this.isWhitePiece(piece)) {
                        this.selectedSquare = { row, col };
                        this.highlightPossibleMoves(row, col);
                    } else {
                        this.selectedSquare = null;
                        this.clearHighlights();
                    }
                } else if (piece && this.isWhitePiece(piece)) {
                    this.selectedSquare = { row, col };
                    this.highlightPossibleMoves(row, col);
                }
            }

            isWhitePiece(piece) { return piece && piece === piece.toUpperCase(); }

            clearHighlights() {
                this.squareElements.forEach(s => s.classList.remove('selected', 'possible-move', 'hint'));
            }

            highlightPossibleMoves(row, col) {
                this.clearHighlights();
                this.squareElements[row * 8 + col].classList.add('selected');
                const moves = this.getAllPossibleMovesForPiece(row, col, this.board, this.castlingRights, this.enPassantTarget);
                moves.forEach(move => {
                    this.squareElements[move.toRow * 8 + move.toCol].classList.add('possible-move');
                });
            }
            
            makeMove(fromRow, fromCol, toRow, toCol) {
                const { newBoard, moveData } = this.performMove(this.board, { fromRow, fromCol, toRow, toCol }, this.castlingRights, this.enPassantTarget);
                
                this.moveHistory.push(moveData);
                this.board = newBoard;
                const piece = moveData.from.piece;
                const capturedPiece = moveData.to.piece;
                const moveNotation = this.getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece, moveData.special.isEnPassant, moveData.special.isCastling, moveData.special.isPromotion);
                this.moves.push(moveNotation);

                this.castlingRights = this.getUpdatedCastlingRights(this.board, this.castlingRights);
                this.enPassantTarget = piece.toLowerCase() === 'p' && Math.abs(fromRow - toRow) === 2 ? { row: (fromRow + toRow) / 2, col: fromCol } : null;

                this.lastMove = { fromRow, fromCol, toRow, toCol };
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                this.updateBoard();
                this.updateMovesList();
                this.updateGameStatus();
                this.provideFeedback(piece, capturedPiece);
                
                if (this.isCheckmate() || this.isStalemate()) {
                    this.gameOver = true;
                    this.endGame();
                }
            }
            
            undoMove() {
                if (this.gameOver) return;
                if (this.moveHistory.length < (this.currentPlayer === 'white' ? 1 : 2)) {
                    this.feedbackEl.textContent = "Je kunt niet terug als je aan de beurt bent.";
                    this.feedbackEl.className = 'feedback warning';
                    return;
                }
                
                for (let i = 0; i < 2; i++) {
                    if (this.moveHistory.length === 0) break;
                    const lastMove = this.moveHistory.pop();
                    const { from, to, special, castlingRights, enPassantTarget } = lastMove;
                    
                    this.board[from.row][from.col] = from.piece;
                    this.board[to.row][to.col] = to.piece;
                    
                    if (special.isEnPassant) {
                        const capturedPawnRow = this.isWhitePiece(from.piece) ? to.row + 1 : to.row - 1;
                        this.board[capturedPawnRow][to.col] = this.isWhitePiece(from.piece) ? 'p' : 'P';
                    }
                    if (special.isCastling) {
                        const rookFromCol = to.col > from.col ? 5 : 3;
                        const rookToCol = to.col > from.col ? 7 : 0;
                        this.board[from.row][rookToCol] = this.board[from.row][rookFromCol];
                        this.board[from.row][rookFromCol] = '';
                    }
                    this.castlingRights = castlingRights;
                    this.enPassantTarget = enPassantTarget;
                    this.moves.pop();
                }
                
                this.currentPlayer = 'white';
                this.lastMove = null;
                this.gameOver = false;
                
                this.updateBoard();
                this.updateMovesList();
                this.updateGameStatus();
                this.feedbackEl.textContent = 'Zetten teruggedraaid. Probeer iets anders!';
                this.feedbackEl.className = 'feedback';
            }
            
            getNewBoardState(board, move, castlingRights, enPassantTarget) {
                const { newBoard, moveData } = this.performMove(board, move, castlingRights, enPassantTarget);
                const newCastlingRights = this.getUpdatedCastlingRights(newBoard, castlingRights);
                const newEnPassantTarget = moveData.from.piece.toLowerCase() === 'p' && Math.abs(move.fromRow - move.toRow) === 2 ? { row: (move.fromRow + move.toRow) / 2, col: move.fromCol } : null;
                return { newBoard, newCastlingRights, newEnPassantTarget };
            }

            performMove(board, move, castlingRights, enPassantTarget) {
                let newBoard = board.map(r => r.slice());
                const { fromRow, fromCol, toRow, toCol } = move;
                const piece = newBoard[fromRow][fromCol];
                const capturedPiece = newBoard[toRow][toCol];
                const pieceType = piece.toLowerCase();
                let isEnPassant = pieceType === 'p' && !capturedPiece && Math.abs(fromCol - toCol) === 1;
                let isCastling = pieceType === 'k' && Math.abs(fromCol - toCol) === 2;
                let isPromotion = pieceType === 'p' && (toRow === 0 || toRow === 7);
                const moveData = {from:{row:fromRow,col:fromCol,piece}, to:{row:toRow,col:toCol,piece:capturedPiece}, special:{isEnPassant,isCastling,isPromotion}, castlingRights:{...castlingRights}, enPassantTarget:enPassantTarget};
                if (isEnPassant) { const capturedPawnRow = this.isWhitePiece(piece) ? toRow + 1 : toRow - 1; moveData.to.piece = newBoard[capturedPawnRow][toCol]; newBoard[capturedPawnRow][toCol] = ''; }
                if (isCastling) { const rookFromCol = toCol > fromCol ? 7 : 0; const rookToCol = toCol > fromCol ? 5 : 3; newBoard[toRow][rookToCol] = newBoard[toRow][rookFromCol]; newBoard[toRow][rookFromCol] = ''; }
                newBoard[toRow][toCol] = isPromotion ? (this.isWhitePiece(piece) ? 'Q' : 'q') : piece;
                newBoard[fromRow][fromCol] = '';
                return { newBoard, moveData };
            }
            
            getUpdatedCastlingRights(board, currentRights) {
                const newRights = { ...currentRights };
                if (board[7][4] !== 'K') { newRights.whiteKingSide = newRights.whiteQueenSide = false; }
                if (board[0][4] !== 'k') { newRights.blackKingSide = newRights.blackQueenSide = false; }
                if (board[7][0] !== 'R') { newRights.whiteQueenSide = false; }
                if (board[7][7] !== 'R') { newRights.whiteKingSide = false; }
                if (board[0][0] !== 'r') { newRights.blackQueenSide = false; }
                if (board[0][7] !== 'r') { newRights.blackKingSide = false; }
                return newRights;
            }

            isValidMove(fromRow, fromCol, toRow, toCol, board, castlingRights = this.castlingRights, enPassantTarget = this.enPassantTarget) {
                const piece = board[fromRow][fromCol];
                const targetPiece = board[toRow][toCol];
                const isWhite = this.isWhitePiece(piece);
                if (!piece) return false;
                if (targetPiece && this.isWhitePiece(targetPiece) === isWhite) return false;
                if (!this.isValidPieceMove(fromRow, fromCol, toRow, toCol, piece, board, enPassantTarget, castlingRights)) return false;
                let tempBoard = board.map(r => r.slice()); tempBoard[toRow][toCol] = piece; tempBoard[fromRow][fromCol] = '';
                return !this.isInCheck(isWhite ? 'white' : 'black', tempBoard);
            }
            
            isValidPieceMove(fromRow, fromCol, toRow, toCol, piece, board, enPassantTarget, castlingRights) {
                const pieceType = piece.toLowerCase();
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                switch (pieceType) {
                    case 'p': return this.isValidPawnMove(fromRow, fromCol, toRow, toCol, piece, board, enPassantTarget);
                    case 'r': return (rowDiff === 0 || colDiff === 0) && this.isPathClear(fromRow, fromCol, toRow, toCol, board);
                    case 'n': return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                    case 'b': return rowDiff === colDiff && this.isPathClear(fromRow, fromCol, toRow, toCol, board);
                    case 'q': return ((rowDiff === 0 || colDiff === 0) || rowDiff === colDiff) && this.isPathClear(fromRow, fromCol, toRow, toCol, board);
                    case 'k': return this.isValidKingMove(fromRow, fromCol, toRow, toCol, piece, board, castlingRights);
                    default: return false;
                }
            }

            isValidPawnMove(fromRow, fromCol, toRow, toCol, piece, board, enPassantTarget) {
                const direction = this.isWhitePiece(piece) ? -1 : 1;
                const startRow = this.isWhitePiece(piece) ? 6 : 1;
                const targetPiece = board[toRow][toCol];
                if (fromCol === toCol && !targetPiece) { if (toRow === fromRow + direction) return true; if (fromRow === startRow && toRow === fromRow + 2 * direction && !board[fromRow + direction][fromCol]) return true; }
                if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) { if (targetPiece) return true; if (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col) return true; }
                return false;
            }
            
            isValidKingMove(fromRow, fromCol, toRow, toCol, piece, board, castlingRights) {
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                if (rowDiff <= 1 && colDiff <= 1) return true;
                if (rowDiff === 0 && colDiff === 2) return this.canCastle(fromRow, fromCol, toRow, toCol, piece, board, castlingRights);
                return false;
            }
            
            canCastle(fromRow, fromCol, toRow, toCol, piece, board, castlingRights) {
                const isWhite = this.isWhitePiece(piece);
                const backRank = isWhite ? 7 : 0;
                if (fromRow !== backRank || toRow !== backRank || this.isInCheck(isWhite ? 'white' : 'black', board)) return false;
                const kingSide = toCol > fromCol;
                if (kingSide) {
                    if (!castlingRights[isWhite ? 'whiteKingSide' : 'blackKingSide']) return false;
                    for (let c = fromCol + 1; c < 7; c++) if (board[backRank][c] !== '') return false;
                    for (let c = fromCol; c <= fromCol + 2; c++) if (this.isSquareUnderAttack(backRank, c, isWhite ? 'white' : 'black', board)) return false;
                } else {
                    if (!castlingRights[isWhite ? 'whiteQueenSide' : 'blackQueenSide']) return false;
                    for (let c = fromCol - 1; c > 0; c--) if (board[backRank][c] !== '') return false;
                    for (let c = fromCol; c >= fromCol - 2; c++) if (this.isSquareUnderAttack(backRank, c, isWhite ? 'white' : 'black', board)) return false;
                }
                return true;
            }

            isPathClear(fromRow, fromCol, toRow, toCol, board) {
                const rowStep = Math.sign(toRow - fromRow);
                const colStep = Math.sign(toCol - fromCol);
                let r = fromRow + rowStep, c = fromCol + colStep;
                while (r !== toRow || c !== toCol) { if (board[r][c] !== '') return false; r += rowStep; c += colStep; }
                return true;
            }
            
            isAttacking(fromRow, fromCol, toRow, toCol, piece, board) {
                const pieceType = piece.toLowerCase();
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                if (pieceType === 'p') { const direction = this.isWhitePiece(piece) ? -1 : 1; return toRow === fromRow + direction && colDiff === 1; }
                if (pieceType === 'n') { return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2); }
                if (pieceType === 'k') { return rowDiff <= 1 && colDiff <= 1; }
                if (pieceType === 'r' && (rowDiff === 0 || colDiff === 0)) { return this.isPathClear(fromRow, fromCol, toRow, toCol, board); }
                if (pieceType === 'b' && rowDiff === colDiff) { return this.isPathClear(fromRow, fromCol, toRow, toCol, board); }
                if (pieceType === 'q' && ((rowDiff === 0 || colDiff === 0) || rowDiff === colDiff)) { return this.isPathClear(fromRow, fromCol, toRow, toCol, board); }
                return false;
            }
            
            isSquareUnderAttack(row, col, color, board) {
                const opponentColor = color === 'white' ? 'black' : 'white';
                for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const piece = board[r][c]; if (!piece) continue; const isOpponent = (opponentColor === 'white' && this.isWhitePiece(piece)) || (opponentColor === 'black' && !this.isWhitePiece(piece)); if (!isOpponent) continue; if (this.isAttacking(r, c, row, col, piece, board)) { return true; } } }
                return false;
            }
            
            isInCheck(color, board) {
                let kingPos;
                const kingPiece = color === 'white' ? 'K' : 'k';
                for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { if (board[r][c] === kingPiece) kingPos = { r, c }; } }
                return kingPos ? this.isSquareUnderAttack(kingPos.r, kingPos.c, color, board) : false;
            }
            
            isGameOver(board, player, castlingRights, enPassantTarget) {
                return this.getAllPossibleMoves(player, board, castlingRights, enPassantTarget).length === 0;
            }
            
            isCheckmate() { return this.getAllPossibleMoves(this.currentPlayer).length === 0 && this.isInCheck(this.currentPlayer, this.board); }
            isStalemate() { return this.getAllPossibleMoves(this.currentPlayer).length === 0 && !this.isInCheck(this.currentPlayer, this.board); }

            getAllPossibleMoves(color, board = this.board, castlingRights = this.castlingRights, enPassantTarget = this.enPassantTarget) {
                const moves = [];
                for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const piece = board[r][c]; if (piece && ((color === 'white' && this.isWhitePiece(piece)) || (color === 'black' && !this.isWhitePiece(piece)))) { moves.push(...this.getAllPossibleMovesForPiece(r, c, board, castlingRights, enPassantTarget)); } } }
                return moves;
            }
            
            getAllPossibleMovesForPiece(r, c, board, castlingRights, enPassantTarget) {
                const moves = [];
                const piece = board[r][c];
                for (let toR = 0; toR < 8; toR++) { for (let toC = 0; toC < 8; toC++) { if (this.isValidMove(r, c, toR, toC, board, castlingRights, enPassantTarget)) { moves.push({ fromRow: r, fromCol: c, toRow: toR, toCol: toC, piece }); } } }
                return moves;
            }

            updateMovesList() {
                if (this.moves.length === 0) { this.movesListEl.innerHTML = '<div style="text-align: center; color: #666; font-style: italic;">Nog geen zetten gespeeld</div>'; return; }
                let html = '';
                for (let i = 0; i < this.moves.length; i += 2) { html += `<div class="move-pair">${Math.floor(i / 2) + 1}. ${this.moves[i] || ''} ${this.moves[i + 1] || ''}</div>`; }
                this.movesListEl.innerHTML = html;
                this.movesListEl.scrollTop = this.movesListEl.scrollHeight;
            }

            provideFeedback(piece, capturedPiece) {
                let msg = 'Goede zet.';
                if (capturedPiece) { msg = `Goed! Je hebt een ${this.getPieceName(capturedPiece)} geslagen.`; }
                else if (this.isInCheck(this.currentPlayer, this.board)) { msg = 'Schaak! De koning wordt aangevallen.'; }
                this.feedbackEl.textContent = msg;
                this.feedbackEl.className = 'feedback';
            }
            
            getPieceName(p) { const n = {p:'pion',r:'toren',n:'paard',b:'loper',q:'dame',k:'koning'}; return n[p.toLowerCase()]||'stuk'; }

            updateGameStatus() {
                if (this.gameOver) return;
                let text = 'AI denkt na...';
                if (this.currentPlayer === 'white') {
                    text = this.isInCheck('white', this.board) ? 'Je staat schaak!' : 'Jouw beurt - Speel met wit';
                }
                this.gameStatusEl.textContent = text;
                this.gameStatusEl.className = `game-status playing`;
            }
            
            getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece, isEnPassant, isCastling, isPromotion) {
                if (isCastling) return toCol > fromCol ? 'O-O' : 'O-O-O';
                const files = 'abcdefgh';
                const toSquare = files[toCol] + (8 - toRow);
                const pieceSymbol = piece.toUpperCase() === 'P' ? '' : piece.toUpperCase();
                const capture = (capturedPiece || isEnPassant) ? (piece.toUpperCase() === 'P' ? files[fromCol] + 'x' : 'x') : '';
                let notation = `${pieceSymbol}${capture}${toSquare}`;
                if (isPromotion) notation += '=Q';
                
                const tempBoard = this.getNewBoardState(this.board, {fromRow, fromCol, toRow, toCol}, this.castlingRights, this.enPassantTarget).newBoard;
                const opponent = this.isWhitePiece(piece) ? 'black' : 'white';
                if (this.getAllPossibleMoves(opponent, tempBoard).length === 0) {
                     if (this.isInCheck(opponent, tempBoard)) notation += '#';
                } else if (this.isInCheck(opponent, tempBoard)) {
                    notation += '+';
                }
                return notation;
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            new ChessGame();
        });
    </script>
</body>
</html>




