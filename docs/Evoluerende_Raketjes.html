<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Genetisch Algoritme: Reis naar de Zon</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .info-panel {
            background-color: rgba(26, 32, 44, 0.8);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-yellow-400">3D Genetisch Algoritme: Reis naar de Zon</h1>
        <p class="text-center text-gray-400 mb-4">Sleep met de muis om de camera te draaien. Raketjes evolueren om de planeten te ontwijken.</p>

        <div class="relative">
            <canvas id="gameCanvas"></canvas>
            <div id="infoPanel" class="info-panel absolute top-2 left-2 p-3 rounded-lg text-sm">
                <p>Generatie: <span id="generation-count" class="font-semibold text-cyan-400">0</span></p>
                <p>Levensduur: <span id="lifespan-count" class="font-semibold text-yellow-400">0</span></p>
                <p>Beste Fitness: <span id="best-fitness" class="font-semibold text-green-400">0</span></p>
                <p>Doel bereikt: <span id="reached-target" class="font-semibold text-green-400">0</span></p>
            </div>
        </div>

        <div class="mt-4 text-center">
             <button id="reset-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
                Herstart Simulatie
            </button>
        </div>
    </div>

    <!-- Three.js bibliotheken -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
    // --- Basis Setup ---
    const canvas = document.getElementById('gameCanvas');
    const uiPanel = document.querySelector('.w-full.max-w-5xl');

    // --- DOM Elementen ---
    const generationCountSpan = document.getElementById('generation-count');
    const lifespanCountSpan = document.getElementById('lifespan-count');
    const bestFitnessSpan = document.getElementById('best-fitness');
    const reachedTargetSpan = document.getElementById('reached-target');
    const resetButton = document.getElementById('reset-button');

    // --- Three.js Variabelen ---
    let scene, camera, renderer, controls;
    let starfield;
    let targetMesh;
    const obstacleMeshes = [];

    // --- Simulatie Variabelen ---
    let lifespan = 500;
    let population;
    let count = 0;
    let generation = 0;
    let bestFitness = 0;
    
    // Doel en startpositie (nu in 3D)
    const target = new THREE.Vector3(0, 50, 0);
    const rocketStartPos = new THREE.Vector3(0, -250, 0);
    let obstacles = [];

    // --- Genetisch Algoritme Classes (aangepast voor 3D) ---
    class DNA {
        constructor(genes) {
            if (genes) {
                this.genes = genes;
            } else {
                this.genes = [];
                for (let i = 0; i < lifespan; i++) {
                    const force = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    );
                    force.normalize().multiplyScalar(0.4); // Kracht normaliseren
                    this.genes.push(force);
                }
            }
        }

        crossover(partner) {
            let newGenes = [];
            let mid = Math.floor(Math.random() * this.genes.length);
            for (let i = 0; i < this.genes.length; i++) {
                newGenes[i] = (i > mid) ? this.genes[i] : partner.genes[i];
            }
            return new DNA(newGenes);
        }

        mutation(mutationRate) {
            for (let i = 0; i < this.genes.length; i++) {
                if (Math.random() < mutationRate) {
                     const force = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    );
                    force.normalize().multiplyScalar(0.4);
                    this.genes[i] = force;
                }
            }
        }
    }

    class Rocket {
        constructor(dna) {
            this.pos = rocketStartPos.clone();
            this.vel = new THREE.Vector3();
            this.acc = new THREE.Vector3();
            this.dna = dna || new DNA();
            this.fitness = 0;
            this.completed = false;
            this.crashed = false;
            this.timeToTarget = Infinity;
            
            // Maak het 3D model voor de raket
            this.mesh = this.createRocketMesh();
            scene.add(this.mesh);
        }

        createRocketMesh() {
            const group = new THREE.Group();

            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.4 });
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xff4444, metalness: 0.5, roughness: 0.5 });
            
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0, 4, 15, 8), bodyMat);
            body.rotation.x = Math.PI / 2;
            group.add(body);
            
            this.flameMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.8 });
            this.flame = new THREE.Mesh(new THREE.ConeGeometry(2, 5, 8), this.flameMaterial);
            this.flame.position.y = -10;
            this.flame.rotation.x = Math.PI;
            group.add(this.flame);

            group.rotation.x = -Math.PI / 2;
            return group;
        }

        applyForce(force) {
            this.acc.add(force);
        }

        calcFitness() {
            const d = this.pos.distanceTo(target);
            this.fitness = 1 / (d + 1);
            if (this.completed) {
                this.fitness *= 20;
                this.fitness *= (lifespan / this.timeToTarget);
            }
            if (this.crashed) {
                this.fitness /= 20;
            }
        }

        update() {
            if (this.pos.distanceTo(target) < 10 && !this.completed) {
                this.completed = true;
                this.pos.copy(target);
                this.timeToTarget = count;
            }

            for (const obs of obstacles) {
                if (this.pos.distanceTo(obs.pos) < obs.radius) {
                    this.crashed = true;
                    break;
                }
            }
             if (this.pos.y > 300 || this.pos.y < -300 || this.pos.x > 300 || this.pos.x < -300 || this.pos.z > 300 || this.pos.z < -300) {
                 this.crashed = true;
             }

            if (!this.completed && !this.crashed) {
                this.applyForce(this.dna.genes[count]);
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.acc.set(0, 0, 0);
                this.vel.clampLength(0, 5);
            }
            
            this.updateMesh();
        }

        updateMesh() {
            this.mesh.position.copy(this.pos);
             if (this.vel.lengthSq() > 0.01) {
                this.mesh.lookAt(this.pos.clone().add(this.vel));
            }
            
            this.flame.scale.y = 0.5 + Math.random() * 0.8;
            this.flame.visible = !this.crashed && !this.completed;
            
            let opacity = 0.7;
            if (this.crashed) opacity = 0.1;
            if (this.completed) opacity = 1.0;
            this.mesh.children[0].material.opacity = opacity;
            this.mesh.children[0].material.transparent = opacity < 1;
        }
        
        dispose() {
             scene.remove(this.mesh);
             // more complex geometries would need geometry.dispose() and material.dispose()
        }
    }

    class Population {
        constructor(size) {
            this.rockets = [];
            this.popsize = size;
            this.matingpool = [];
            for (let i = 0; i < this.popsize; i++) {
                this.rockets.push(new Rocket());
            }
        }

        evaluate() {
            let maxFit = 0;
            let completedCount = 0;
            this.rockets.forEach(rocket => {
                rocket.calcFitness();
                if (rocket.fitness > maxFit) maxFit = rocket.fitness;
                if (rocket.completed) completedCount++;
            });
            bestFitness = maxFit;
            reachedTargetSpan.textContent = completedCount;

            this.matingpool = [];
            this.rockets.forEach(rocket => {
                const n = (rocket.fitness / maxFit) * 100;
                for (let j = 0; j < n; j++) {
                    this.matingpool.push(rocket);
                }
            });
        }

        selection() {
            let newRockets = [];
             this.rockets.forEach(r => r.dispose());

            for (let i = 0; i < this.popsize; i++) {
                if (this.matingpool.length > 0) {
                    const parentA = this.matingpool[Math.floor(Math.random() * this.matingpool.length)];
                    const parentB = this.matingpool[Math.floor(Math.random() * this.matingpool.length)];
                    const childDNA = parentA.dna.crossover(parentB.dna);
                    childDNA.mutation(0.01);
                    newRockets.push(new Rocket(childDNA));
                } else {
                    // Als iedereen crasht, start opnieuw
                    newRockets.push(new Rocket());
                }
            }
            this.rockets = newRockets;
        }

        run() {
            this.rockets.forEach(rocket => rocket.update());
        }
    }
    
    // --- Initialisatie & Game Loop ---
    
    function init() {
        // Scene
        scene = new THREE.Scene();
        
        // Camera
        camera = new THREE.PerspectiveCamera(75, uiPanel.clientWidth / (window.innerHeight * 0.7), 0.1, 2000);
        camera.position.set(0, -150, 250);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true, alpha: true });
        renderer.setSize(uiPanel.clientWidth, window.innerHeight * 0.7);
        renderer.setClearColor(0x000000, 0);

        // Lights
        scene.add(new THREE.AmbientLight(0x404040, 1.5));
        const sunLight = new THREE.PointLight(0xffddaa, 2, 2000);
        sunLight.position.copy(target);
        scene.add(sunLight);
        
        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Starfield
        const starGeo = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            starVertices.push(
                (Math.random() - 0.5) * 2000,
                (Math.random() - 0.5) * 2000,
                (Math.random() - 0.5) * 2000
            );
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
        starfield = new THREE.Points(starGeo, starMat);
        scene.add(starfield);

        setupSimulation();
    }

    function setupSimulation() {
        // Verwijder oude objecten als die er zijn
        if (population) population.rockets.forEach(r => r.dispose());
        obstacleMeshes.forEach(m => scene.remove(m));
        obstacleMeshes.length = 0;
        obstacles.length = 0;
        
        // Doel (Zon)
        if (!targetMesh) {
            const targetGeo = new THREE.SphereGeometry(10, 32, 32);
            const targetMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            targetMesh = new THREE.Mesh(targetGeo, targetMat);
            scene.add(targetMesh);
        }
        targetMesh.position.copy(target);

        // Obstakels (Planeten)
        const planetData = [
            { pos: new THREE.Vector3(80, 20, -50), radius: 25, color: 0xff6b6b },
            { pos: new THREE.Vector3(-100, -80, 20), radius: 35, color: 0x4ecdc4 },
            { pos: new THREE.Vector3(0, -150, 80), radius: 20, color: 0xf0e68c }
        ];
        
        planetData.forEach(data => {
            obstacles.push(data);
            const obsGeo = new THREE.SphereGeometry(data.radius, 32, 32);
            const obsMat = new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.8 });
            const obsMesh = new THREE.Mesh(obsGeo, obsMat);
            obsMesh.position.copy(data.pos);
            scene.add(obsMesh);
            obstacleMeshes.push(obsMesh);
        });

        population = new Population(100);
        count = 0;
        generation = 0;
        bestFitness = 0;
        generationCountSpan.textContent = generation;
    }

    function animate() {
        requestAnimationFrame(animate);

        population.run();
        
        count++;
        if (count >= lifespan) {
            population.evaluate();
            population.selection();
            count = 0;
            generation++;
            generationCountSpan.textContent = generation;
        }
        
        // Update UI
        lifespanCountSpan.textContent = `${count}/${lifespan}`;
        bestFitnessSpan.textContent = bestFitness.toFixed(4);

        controls.update();
        renderer.render(scene, camera);
    }
    
    function onWindowResize() {
        camera.aspect = uiPanel.clientWidth / (window.innerHeight * 0.7);
        camera.updateProjectionMatrix();
        renderer.setSize(uiPanel.clientWidth, window.innerHeight * 0.7);
    }
    
    // --- Start ---
    window.addEventListener('resize', onWindowResize);
    resetButton.addEventListener('click', setupSimulation);
    
    init();
    animate();

    </script>
</body>
</html>